<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Quant Multi-Timeframe Cluster & Forecast Analyzer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .gradient-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .text-profit { color: #10b981; }
        .text-loss { color: #ef4444; }
        .text-warning { color: #f59e0b; }
        .bg-profit { background-color: #10b981; }
        .bg-loss { background-color: #ef4444; }
        .bg-warning { background-color: #f59e0b; }
        .btn-primary { background-color: #667eea; color: white; }
        .btn-primary:hover { background-color: #5a67d8; }
        .btn-secondary { border: 1px solid #d1d5db; }
        .btn-secondary:hover { background-color: #f3f4f6; }
        .forecast-card { transition: all 0.3s ease; }
        .forecast-card:hover { transform: translateY(-2px); box-shadow: 0 10px 25px rgba(0,0,0,0.1); }
        .badge { padding: 0.25rem 0.75rem; border-radius: 0.375rem; font-size: 0.75rem; font-weight: 500; }
        .badge.up { background-color: #10b981; color: white; }
        .badge.down { background-color: #ef4444; color: white; }
        .badge.confluence { background-color: #8b5cf6; color: white; }
    </style>
</head>
<body class="bg-gray-50">
    <div id="app">
        <!-- Header -->
        <div class="gradient-primary text-white p-8 mb-8">
            <div class="container mx-auto text-center">
                <h1 class="text-4xl font-bold mb-2">üìä Enhanced Quant Multi-Timeframe Cluster & Forecast Analyzer</h1>
                <p class="text-lg opacity-90">Professional Statistical Analysis with Monte Carlo Forecasting</p>
            </div>
        </div>

        <div class="container mx-auto px-4 space-y-8">
            <!-- Controls -->
            <div class="bg-white rounded-lg shadow-lg p-6">
                <h2 class="text-xl font-bold mb-4">üìÅ Data Upload & Configuration</h2>
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium mb-2">Upload CSV with OHLC data (Date,Open,High,Low,Close,Volume):</label>
                        <input type="file" id="csvFile" accept=".csv" class="w-full p-2 border border-gray-300 rounded-md">
                    </div>
                    
                    <div>
                        <label class="block text-sm font-medium mb-2">Filter by Year (optional):</label>
                        <input type="number" id="yearFilter" placeholder="e.g., 2025" class="max-w-xs p-2 border border-gray-300 rounded-md">
                    </div>

                    <div class="flex gap-4">
                        <button id="analyzeBtn" class="btn-primary px-4 py-2 rounded-md disabled:opacity-50">Analyze Data</button>
                        <button id="downloadBtn" class="btn-secondary px-4 py-2 rounded-md disabled:opacity-50" disabled>Download Results CSV</button>
                    </div>

                    <div id="dataQuality" class="hidden grid grid-cols-2 md:grid-cols-4 gap-4 mt-4"></div>
                </div>
            </div>

            <!-- Statistics Panel -->
            <div id="statisticsPanel" class="hidden bg-white rounded-lg shadow-lg p-6">
                <h2 class="text-xl font-bold mb-4">üìà Data Statistics</h2>
                <div id="statisticsContent"></div>
            </div>

            <!-- Main Analysis Tabs -->
            <div id="analysisSection" class="hidden">
                <div class="bg-white rounded-lg shadow-lg">
                    <div class="border-b border-gray-200">
                        <nav class="flex space-x-8 px-6" aria-label="Tabs">
                            <button class="tab-btn active py-2 px-1 border-b-2 border-blue-500 font-medium text-sm text-blue-600" data-tab="clusters">üéØ Statistical Clusters</button>
                            <button class="tab-btn py-2 px-1 border-b-2 border-transparent font-medium text-sm text-gray-500 hover:text-gray-700" data-tab="forecast">üìä Monte Carlo Forecasts</button>
                            <button class="tab-btn py-2 px-1 border-b-2 border-transparent font-medium text-sm text-gray-500 hover:text-gray-700" data-tab="best-days">üìÖ High Volatility Days</button>
                        </nav>
                    </div>

                    <div class="p-6">
                        <div id="clusters-tab" class="tab-content">
                            <div id="clusterTable"></div>
                        </div>
                        <div id="forecast-tab" class="tab-content hidden">
                            <div id="forecastCards"></div>
                        </div>
                        <div id="best-days-tab" class="tab-content hidden">
                            <div id="bestDaysTable"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Loading/Empty States -->
            <div id="loadingState" class="hidden bg-white rounded-lg shadow-lg p-8 text-center">
                <p class="text-gray-600">üîÑ Analyzing data...</p>
            </div>

            <div id="emptyState" class="bg-white rounded-lg shadow-lg p-8 text-center">
                <p class="text-gray-600 mb-4">‚ö†Ô∏è Upload a CSV file with OHLC data to begin enhanced statistical analysis.</p>
                <p class="text-sm text-gray-500">Supports automatic data validation, outlier detection, and missing data handling.</p>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let csvData = [];
        let clusterData = [];
        let bestDays = [];
        let forecastData = {};
        let analysisComplete = false;

        // Utility functions
        function calculateZScore(value, mean, std) {
            return std === 0 ? 0 : (value - mean) / std;
        }

        function calculatePercentile(arr, percentile) {
            const sorted = [...arr].sort((a, b) => a - b);
            const index = Math.ceil((percentile / 100) * sorted.length) - 1;
            return sorted[Math.max(0, index)] || 0;
        }

        function generateNormalRandom() {
            let u = 0, v = 0;
            while(u === 0) u = Math.random();
            while(v === 0) v = Math.random();
            return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }

        function kMeansCluster(data, k = 10) {
            if (data.length === 0) return [];
            
            const min = Math.min(...data);
            const max = Math.max(...data);
            const range = max - min;
            
            let centroids = Array.from({ length: k }, (_, i) => min + (range * i) / (k - 1));
            let clusters = new Array(data.length).fill(0);
            
            for (let iter = 0; iter < 50; iter++) {
                data.forEach((point, i) => {
                    let minDist = Infinity;
                    let bestCluster = 0;
                    centroids.forEach((centroid, j) => {
                        const dist = Math.abs(point - centroid);
                        if (dist < minDist) {
                            minDist = dist;
                            bestCluster = j;
                        }
                    });
                    clusters[i] = bestCluster;
                });
                
                const newCentroids = new Array(k).fill(0);
                const counts = new Array(k).fill(0);
                
                data.forEach((point, i) => {
                    const cluster = clusters[i];
                    newCentroids[cluster] += point;
                    counts[cluster]++;
                });
                
                let converged = true;
                for (let i = 0; i < k; i++) {
                    if (counts[i] > 0) {
                        const newCentroid = newCentroids[i] / counts[i];
                        if (Math.abs(newCentroid - centroids[i]) > 0.0001) {
                            converged = false;
                        }
                        centroids[i] = newCentroid;
                    }
                }
                
                if (converged) break;
            }
            
            return clusters;
        }

        function validateOHLCData(row) {
            const { open, high, low, close } = row;
            
            if (isNaN(open) || isNaN(high) || isNaN(low) || isNaN(close)) return false;
            if (open <= 0 || high <= 0 || low <= 0 || close <= 0) return false;
            if (high < Math.max(open, close) || low > Math.min(open, close)) return false;
            if (high < low) return false;
            
            return true;
        }

        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            const headers = lines[0].toLowerCase().split(',').map(h => h.trim());
            
            const dateIndex = headers.findIndex(h => h.includes('date') || h.includes('time') || h === 'timestamp');
            const openIndex = headers.findIndex(h => h.includes('open'));
            const highIndex = headers.findIndex(h => h.includes('high'));
            const lowIndex = headers.findIndex(h => h.includes('low'));
            const closeIndex = headers.findIndex(h => h.includes('close'));
            const volumeIndex = headers.findIndex(h => h.includes('volume') || h.includes('vol'));

            if (dateIndex === -1 || openIndex === -1 || highIndex === -1 || lowIndex === -1 || closeIndex === -1) {
                throw new Error('CSV must contain Date, Open, High, Low, Close columns');
            }

            const data = [];
            let validRows = 0;
            let invalidRows = 0;
            
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',').map(v => v.trim().replace(/"/g, ''));
                
                if (values.length < Math.max(dateIndex, openIndex, highIndex, lowIndex, closeIndex) + 1) {
                    invalidRows++;
                    continue;
                }

                const row = {
                    date: values[dateIndex],
                    open: parseFloat(values[openIndex]),
                    high: parseFloat(values[highIndex]),
                    low: parseFloat(values[lowIndex]),
                    close: parseFloat(values[closeIndex]),
                    volume: volumeIndex !== -1 ? parseFloat(values[volumeIndex]) : undefined,
                    dateObj: new Date(values[dateIndex]),
                    dailyAvg: 0,
                    dailyRange: 0,
                    direction: 'Up',
                    logReturn: 0
                };

                if (validateOHLCData(row) && !isNaN(row.dateObj.getTime())) {
                    row.dailyAvg = (row.open + row.high + row.low + row.close) / 4;
                    row.dailyRange = row.high - row.low;
                    row.direction = row.close > row.open ? 'Up' : 'Down';
                    data.push(row);
                    validRows++;
                } else {
                    invalidRows++;
                }
            }
            
            data.sort((a, b) => a.dateObj.getTime() - b.dateObj.getTime());
            
            const logReturns = [];
            for (let i = 1; i < data.length; i++) {
                const logReturn = Math.log(data[i].close / data[i-1].close);
                data[i].logReturn = logReturn;
                logReturns.push(logReturn);
            }
            
            const q1 = calculatePercentile(logReturns, 25);
            const q3 = calculatePercentile(logReturns, 75);
            const iqr = q3 - q1;
            const lowerBound = q1 - 1.5 * iqr;
            const upperBound = q3 + 1.5 * iqr;
            
            let outlierCount = 0;
            data.forEach(row => {
                if (row.logReturn < lowerBound || row.logReturn > upperBound) {
                    row.isOutlier = true;
                    outlierCount++;
                }
            });
            
            updateDataQuality({
                totalRows: lines.length - 1,
                validRows,
                outliers: outlierCount,
                missingData: invalidRows
            });
            
            return data;
        }

        function updateDataQuality(quality) {
            const qualityDiv = document.getElementById('dataQuality');
            qualityDiv.className = 'grid grid-cols-2 md:grid-cols-4 gap-4 mt-4';
            qualityDiv.innerHTML = `
                <div class="flex items-center gap-2 text-sm">
                    <span class="badge bg-gray-200 text-gray-800">${quality.validRows} valid rows</span>
                </div>
                <div class="flex items-center gap-2 text-sm">
                    <span class="badge bg-yellow-200 text-yellow-800">${quality.outliers} outliers</span>
                </div>
                <div class="flex items-center gap-2 text-sm">
                    <span class="badge bg-red-200 text-red-800">${quality.missingData} invalid</span>
                </div>
                <div class="flex items-center gap-2 text-sm">
                    <span class="badge bg-green-200 text-green-800">${((quality.validRows / quality.totalRows) * 100).toFixed(1)}% quality</span>
                </div>
            `;
        }

        function analyzeData() {
            if (!csvData.length) {
                alert("Load CSV data first!");
                return;
            }

            showLoading(true);
            
            const yearFilter = document.getElementById('yearFilter').value;
            let filteredData = csvData;
            if (yearFilter) {
                filteredData = csvData.filter(row => row.dateObj.getFullYear() === parseInt(yearFilter));
            }

            // Calculate technical indicators
            const trueRanges = [];
            let prevClose = null;

            filteredData.forEach((row, i) => {
                row.momentum1 = i >= 1 ? (row.close - filteredData[i-1].close) / filteredData[i-1].close : 0;
                row.momentum3 = i >= 3 ? (row.close - filteredData[i-3].close) / filteredData[i-3].close : 0;
                row.momentum5 = i >= 5 ? (row.close - filteredData[i-5].close) / filteredData[i-5].close : 0;
                row.momentum10 = i >= 10 ? (row.close - filteredData[i-10].close) / filteredData[i-10].close : 0;

                if (i >= 5) {
                    const returns5 = filteredData.slice(i-4, i+1).map(r => r.logReturn);
                    row.volatility5 = Math.sqrt(returns5.reduce((sum, r) => sum + r*r, 0) / 5) * Math.sqrt(252);
                }
                
                if (i >= 10) {
                    const returns10 = filteredData.slice(i-9, i+1).map(r => r.logReturn);
                    row.volatility10 = Math.sqrt(returns10.reduce((sum, r) => sum + r*r, 0) / 10) * Math.sqrt(252);
                }
                
                if (i >= 20) {
                    const returns20 = filteredData.slice(i-19, i+1).map(r => r.logReturn);
                    row.volatility20 = Math.sqrt(returns20.reduce((sum, r) => sum + r*r, 0) / 20) * Math.sqrt(252);
                }

                [1, 3, 5, 10].forEach(days => {
                    if (i + days < filteredData.length) {
                        const futureReturn = (filteredData[i + days].close - row.close) / row.close;
                        row[`return${days}`] = futureReturn;
                    }
                });

                if (prevClose !== null) {
                    const tr = Math.max(
                        row.high - row.low,
                        Math.abs(row.high - prevClose),
                        Math.abs(row.low - prevClose)
                    );
                    trueRanges.push(tr);
                }
                prevClose = row.close;
            });

            // K-means clustering
            const dailyAvgs = filteredData.map(r => r.dailyAvg);
            const clusterAssignments = kMeansCluster(dailyAvgs, 15);
            
            const clusters = {};
            
            filteredData.forEach((row, i) => {
                const clusterIndex = clusterAssignments[i];
                const clusterKey = `cluster_${clusterIndex}`;
                
                if (!clusters[clusterKey]) {
                    clusters[clusterKey] = {
                        count: 0,
                        up: 0,
                        down: 0,
                        lastDate: row.dateObj,
                        returns: [],
                        history: [],
                        prices: []
                    };
                }

                clusters[clusterKey].count += 1;
                clusters[clusterKey].up += row.direction === 'Up' ? 1 : 0;
                clusters[clusterKey].down += row.direction === 'Down' ? 1 : 0;
                clusters[clusterKey].lastDate = row.dateObj;
                clusters[clusterKey].history.push(row);
                clusters[clusterKey].prices.push(row.dailyAvg);

                [1, 3, 5, 10].forEach(days => {
                    if (row[`return${days}`] !== undefined) {
                        clusters[clusterKey].returns.push({
                            days,
                            ret: row[`return${days}`]
                        });
                    }
                });
            });

            // Process clusters
            clusterData = Object.keys(clusters).map(clusterKey => {
                const obj = clusters[clusterKey];
                const avgPrice = obj.prices.reduce((a, b) => a + b, 0) / obj.prices.length;
                const upPct = obj.up / obj.count;
                const recencyFactor = 1 / ((Date.now() - obj.lastDate.getTime()) / (1000 * 60 * 60 * 24) + 1);
                
                const avgVolatility = obj.history.reduce((sum, d) => sum + (d.volatility20 || 0.2), 0) / obj.count;
                const weightedScore = obj.count * upPct * recencyFactor * (1 / (avgVolatility + 0.1));

                const expectedReturns = {};
                const returnStats = {};
                
                [1, 3, 5, 10].forEach(days => {
                    const returnsForDays = obj.returns.filter(x => x.days === days).map(x => x.ret);
                    if (returnsForDays.length > 0) {
                        const mean = returnsForDays.reduce((a, b) => a + b, 0) / returnsForDays.length;
                        const variance = returnsForDays.reduce((sum, ret) => sum + Math.pow(ret - mean, 2), 0) / returnsForDays.length;
                        const std = Math.sqrt(variance);
                        
                        returnStats[days] = { mean, std, returns: returnsForDays };
                        expectedReturns[`R${days}`] = (mean * 100).toFixed(2) + '%';
                    } else {
                        expectedReturns[`R${days}`] = '0.00%';
                    }
                });

                const highs = obj.history.map(d => d.high - d.dailyAvg);
                const lows = obj.history.map(d => d.dailyAvg - d.low);
                const meanHigh = highs.reduce((a, b) => a + b, 0) / highs.length || 0;
                const meanLow = lows.reduce((a, b) => a + b, 0) / lows.length || 0;

                return {
                    cluster: avgPrice.toFixed(4),
                    count: obj.count,
                    up: obj.up,
                    down: obj.down,
                    upPct: (upPct * 100).toFixed(1) + '%',
                    lastDate: obj.lastDate.toISOString().split('T')[0],
                    weightedScore: weightedScore.toFixed(4),
                    expectedReturns,
                    expectedHigh: (avgPrice + meanHigh).toFixed(4),
                    expectedLow: (avgPrice - meanLow).toFixed(4),
                    returnStats
                };
            });

            clusterData.sort((a, b) => parseFloat(b.weightedScore) - parseFloat(a.weightedScore));

            // Enhanced Monte Carlo forecasting
            const lastRow = filteredData[filteredData.length - 1];
            if (!lastRow) {
                showLoading(false);
                return;
            }

            const closestCluster = clusterData.reduce((prev, curr) => {
                return Math.abs(lastRow.dailyAvg - parseFloat(curr.cluster)) < 
                       Math.abs(lastRow.dailyAvg - parseFloat(prev.cluster)) ? curr : prev;
            });

            // Get recent returns for simulation
            const recentReturns = filteredData.slice(-60).map(d => d.logReturn).filter(r => !isNaN(r) && isFinite(r));
            const historicalMean = recentReturns.reduce((sum, ret) => sum + ret, 0) / recentReturns.length || 0;
            const historicalStd = Math.sqrt(
                recentReturns.reduce((sum, ret) => sum + Math.pow(ret - historicalMean, 2), 0) / recentReturns.length
            ) || 0.02;

            // Monte Carlo simulations
            const simulations = 10000;
            
            const nextDaySimulations = Array.from({ length: simulations }, () => {
                const randomShock = generateNormalRandom();
                return historicalMean + (randomShock * historicalStd);
            });

            const weeklySimulations = Array.from({ length: simulations }, () => {
                let cumulativeReturn = 0;
                for (let i = 0; i < 5; i++) {
                    const randomShock = generateNormalRandom();
                    cumulativeReturn += historicalMean + (randomShock * historicalStd);
                }
                return cumulativeReturn;
            });

            const monthlySimulations = Array.from({ length: simulations }, () => {
                let cumulativeReturn = 0;
                for (let i = 0; i < 21; i++) {
                    const randomShock = generateNormalRandom();
                    cumulativeReturn += historicalMean + (randomShock * historicalStd);
                }
                return cumulativeReturn;
            });

            const nextDayMean = nextDaySimulations.reduce((sum, ret) => sum + ret, 0) / simulations;
            const weeklyMean = weeklySimulations.reduce((sum, ret) => sum + ret, 0) / simulations;
            const monthlyMean = monthlySimulations.reduce((sum, ret) => sum + ret, 0) / simulations;

            const currentPrice = lastRow.close;
            const expectedNextDayHigh = currentPrice * Math.exp(calculatePercentile(nextDaySimulations, 75));
            const expectedNextDayLow = currentPrice * Math.exp(calculatePercentile(nextDaySimulations, 25));

            forecastData = {
                nextDay: {
                    return: nextDayMean,
                    direction: nextDayMean >= 0 ? 'Up' : 'Down',
                    cluster: closestCluster.cluster,
                    expectedHigh: expectedNextDayHigh.toFixed(4),
                    expectedLow: expectedNextDayLow.toFixed(4)
                },
                weekly: {
                    cluster: closestCluster.cluster,
                    count: closestCluster.count,
                    expectedReturn: weeklyMean
                },
                monthly: {
                    cluster: closestCluster.cluster,
                    count: closestCluster.count,
                    expectedReturn: monthlyMean
                }
            };

            // Best days analysis
            const dailyRanges = filteredData.map(d => d.dailyRange);
            const meanRange = dailyRanges.reduce((a, b) => a + b, 0) / dailyRanges.length;
            const stdRange = Math.sqrt(
                dailyRanges.map(x => Math.pow(x - meanRange, 2)).reduce((a, b) => a + b, 0) / dailyRanges.length
            );

            bestDays = filteredData
                .map(d => ({
                    date: d.dateObj,
                    range: d.dailyRange,
                    avgPrice: d.dailyAvg,
                    zScore: calculateZScore(d.dailyRange, meanRange, stdRange),
                    volatility: d.volatility20 || 0,
                    volume: d.volume,
                    isOutlier: d.isOutlier
                }))
                .sort((a, b) => b.zScore - a.zScore)
                .slice(0, 15);

            analysisComplete = true;
            showLoading(false);
            updateUI();
        }

        function showLoading(show) {
            document.getElementById('loadingState').classList.toggle('hidden', !show);
            document.getElementById('emptyState').classList.toggle('hidden', show || csvData.length > 0);
            document.getElementById('analysisSection').classList.toggle('hidden', !analysisComplete);
            document.getElementById('statisticsPanel').classList.toggle('hidden', !analysisComplete);
        }

        function updateUI() {
            document.getElementById('downloadBtn').disabled = !analysisComplete;
            
            // Update cluster table
            updateClusterTable();
            updateForecastCards();
            updateBestDaysTable();
            updateStatisticsPanel();
        }

        function updateClusterTable() {
            const tableDiv = document.getElementById('clusterTable');
            let html = `
                <div class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Cluster</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Count</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Up%</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Weighted Score</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Expected Returns</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Range</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200">
            `;

            clusterData.forEach(cluster => {
                html += `
                    <tr>
                        <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">${cluster.cluster}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${cluster.count}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                            <span class="badge ${parseFloat(cluster.upPct) > 50 ? 'up' : 'down'}">${cluster.upPct}</span>
                        </td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${cluster.weightedScore}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                            <div class="space-y-1">
                                <div>1d: ${cluster.expectedReturns.R1}</div>
                                <div>5d: ${cluster.expectedReturns.R5}</div>
                            </div>
                        </td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                            <div>H: ${cluster.expectedHigh}</div>
                            <div>L: ${cluster.expectedLow}</div>
                        </td>
                    </tr>
                `;
            });

            html += '</tbody></table></div>';
            tableDiv.innerHTML = html;
        }

        function updateForecastCards() {
            const cardsDiv = document.getElementById('forecastCards');
            const { nextDay, weekly, monthly } = forecastData;

            cardsDiv.innerHTML = `
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <!-- Next-Day Forecast -->
                    <div class="forecast-card bg-white rounded-lg shadow-lg p-6">
                        <h3 class="text-lg font-bold mb-4 flex items-center gap-2">üéØ Next-Day Forecast</h3>
                        ${nextDay ? `
                            <div class="space-y-4">
                                <div class="text-center">
                                    <div class="text-3xl font-bold ${nextDay.return >= 0 ? 'text-profit' : 'text-loss'}">
                                        ${(nextDay.return * 100).toFixed(2)}%
                                    </div>
                                </div>
                                <div class="space-y-3">
                                    <div class="flex justify-between items-center">
                                        <span class="text-gray-600">Direction:</span>
                                        <span class="badge ${nextDay.direction === 'Up' ? 'up' : 'down'}">
                                            ${nextDay.direction === 'Up' ? 'üìà' : 'üìâ'} ${nextDay.direction}
                                        </span>
                                    </div>
                                    <div class="flex justify-between items-center">
                                        <span class="text-gray-600">Target Cluster:</span>
                                        <span class="font-bold">${nextDay.cluster}</span>
                                    </div>
                                    <div class="flex justify-between items-center">
                                        <span class="text-gray-600">Expected High:</span>
                                        <span class="text-profit font-semibold">${nextDay.expectedHigh}</span>
                                    </div>
                                    <div class="flex justify-between items-center">
                                        <span class="text-gray-600">Expected Low:</span>
                                        <span class="text-loss font-semibold">${nextDay.expectedLow}</span>
                                    </div>
                                </div>
                            </div>
                        ` : '<div class="text-center text-gray-500">No forecast data available</div>'}
                    </div>

                    <!-- Weekly Forecast -->
                    <div class="forecast-card bg-white rounded-lg shadow-lg p-6">
                        <h3 class="text-lg font-bold mb-4 flex items-center gap-2">üìÖ Weekly Forecast</h3>
                        ${weekly ? `
                            <div class="space-y-4">
                                <div class="text-center">
                                    <div class="text-3xl font-bold text-cyan-600">${weekly.cluster}</div>
                                </div>
                                <div class="space-y-3">
                                    <div class="flex justify-between items-center">
                                        <span class="text-gray-600">Historical Count:</span>
                                        <span class="badge bg-gray-200 text-gray-800">${weekly.count}</span>
                                    </div>
                                    <div class="flex justify-between items-center">
                                        <span class="text-gray-600">Expected Return:</span>
                                        <span class="font-semibold ${weekly.expectedReturn >= 0 ? 'text-profit' : 'text-loss'}">
                                            ${(weekly.expectedReturn * 100).toFixed(2)}%
                                        </span>
                                    </div>
                                </div>
                            </div>
                        ` : '<div class="text-center text-gray-500">No weekly forecast available</div>'}
                    </div>

                    <!-- Monthly Forecast -->
                    <div class="forecast-card bg-white rounded-lg shadow-lg p-6">
                        <h3 class="text-lg font-bold mb-4 flex items-center gap-2">üìä Monthly Forecast</h3>
                        ${monthly ? `
                            <div class="space-y-4">
                                <div class="text-center">
                                    <div class="text-3xl font-bold text-amber-600">${monthly.cluster}</div>
                                </div>
                                <div class="space-y-3">
                                    <div class="flex justify-between items-center">
                                        <span class="text-gray-600">Historical Count:</span>
                                        <span class="badge bg-gray-200 text-gray-800">${monthly.count}</span>
                                    </div>
                                    <div class="flex justify-between items-center">
                                        <span class="text-gray-600">Expected Return:</span>
                                        <span class="font-semibold ${monthly.expectedReturn >= 0 ? 'text-profit' : 'text-loss'}">
                                            ${(monthly.expectedReturn * 100).toFixed(2)}%
                                        </span>
                                    </div>
                                </div>
                            </div>
                        ` : '<div class="text-center text-gray-500">No monthly forecast available</div>'}
                    </div>
                </div>
            `;
        }

        function updateBestDaysTable() {
            const tableDiv = document.getElementById('bestDaysTable');
            let html = `
                <div class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Date</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Range</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Avg Price</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Z-Score</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Volatility</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200">
            `;

            bestDays.forEach(day => {
                html += `
                    <tr>
                        <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                            ${day.date.toISOString().split('T')[0]}
                        </td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${day.range.toFixed(4)}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${day.avgPrice.toFixed(4)}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                            <span class="badge ${day.zScore > 2 ? 'bg-red-200 text-red-800' : day.zScore > 1 ? 'bg-yellow-200 text-yellow-800' : 'bg-gray-200 text-gray-800'}">
                                ${day.zScore.toFixed(2)}
                            </span>
                        </td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${(day.volatility * 100).toFixed(2)}%</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                            ${day.isOutlier ? '<span class="badge bg-red-200 text-red-800">Outlier</span>' : '<span class="badge bg-green-200 text-green-800">Normal</span>'}
                        </td>
                    </tr>
                `;
            });

            html += '</tbody></table></div>';
            tableDiv.innerHTML = html;
        }

        function updateStatisticsPanel() {
            const statsDiv = document.getElementById('statisticsContent');
            const totalDays = csvData.length;
            const upDays = csvData.filter(d => d.direction === 'Up').length;
            const avgReturn = csvData.slice(1).reduce((sum, d) => sum + d.logReturn, 0) / (totalDays - 1);
            const volatility = Math.sqrt(csvData.slice(1).reduce((sum, d) => sum + Math.pow(d.logReturn - avgReturn, 2), 0) / (totalDays - 1)) * Math.sqrt(252);

            statsDiv.innerHTML = `
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <div class="text-center">
                        <div class="text-2xl font-bold text-blue-600">${totalDays}</div>
                        <div class="text-sm text-gray-600">Total Days</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold text-green-600">${((upDays / totalDays) * 100).toFixed(1)}%</div>
                        <div class="text-sm text-gray-600">Up Days</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold ${avgReturn >= 0 ? 'text-green-600' : 'text-red-600'}">
                            ${(avgReturn * 100 * 252).toFixed(2)}%
                        </div>
                        <div class="text-sm text-gray-600">Annual Return</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold text-orange-600">${(volatility * 100).toFixed(2)}%</div>
                        <div class="text-sm text-gray-600">Volatility</div>
                    </div>
                </div>
            `;
        }

        function downloadCSV() {
            if (clusterData.length === 0) {
                alert("Analyze data first!");
                return;
            }

            const csv = [
                "Cluster,Count,Up,Down,Up%,LastDate,WeightedScore,ExpReturn1d,ExpReturn3d,ExpReturn5d,ExpReturn10d,ExpHigh,ExpLow",
                ...clusterData.map(c => 
                    `${c.cluster},${c.count},${c.up},${c.down},${c.upPct},${c.lastDate},${c.weightedScore},${c.expectedReturns.R1},${c.expectedReturns.R3},${c.expectedReturns.R5},${c.expectedReturns.R10},${c.expectedHigh},${c.expectedLow}`
                )
            ].join('\n');

            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = "Enhanced_Quant_Analysis.csv";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // Event listeners
        document.getElementById('csvFile').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvText = e.target.result;
                    csvData = parseCSV(csvText);
                    console.log(`Loaded ${csvData.length} valid data points from CSV file.`);
                    document.getElementById('dataQuality').classList.remove('hidden');
                    document.getElementById('emptyState').classList.add('hidden');
                } catch (error) {
                    console.error('Error parsing CSV:', error);
                    alert(error.message || 'Error parsing CSV file');
                }
            };
            reader.readAsText(file);
        });

        document.getElementById('analyzeBtn').addEventListener('click', analyzeData);
        document.getElementById('downloadBtn').addEventListener('click', downloadCSV);

        // Tab switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const tab = this.dataset.tab;
                
                // Update tab buttons
                document.querySelectorAll('.tab-btn').forEach(b => {
                    b.classList.remove('active', 'border-blue-500', 'text-blue-600');
                    b.classList.add('border-transparent', 'text-gray-500');
                });
                this.classList.add('active', 'border-blue-500', 'text-blue-600');
                this.classList.remove('border-transparent', 'text-gray-500');
                
                // Update tab content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.add('hidden');
                });
                document.getElementById(`${tab}-tab`).classList.remove('hidden');
            });
        });
    </script>
</body>
</html>
