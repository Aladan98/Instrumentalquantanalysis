<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Quantitative Multi-Timeframe Analyzer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --background: 222.2 84% 4.9%;
            --foreground: 210 40% 98%;
            --card: 222.2 84% 4.9%;
            --card-foreground: 210 40% 98%;
            --popover: 222.2 84% 4.9%;
            --popover-foreground: 210 40% 98%;
            --primary: 210 40% 98%;
            --primary-foreground: 222.2 84% 4.9%;
            --secondary: 217.2 32.6% 17.5%;
            --secondary-foreground: 210 40% 98%;
            --muted: 217.2 32.6% 17.5%;
            --muted-foreground: 215 20.2% 65.1%;
            --accent: 217.2 32.6% 17.5%;
            --accent-foreground: 210 40% 98%;
            --destructive: 0 62.8% 30.6%;
            --destructive-foreground: 210 40% 98%;
            --border: 217.2 32.6% 17.5%;
            --input: 217.2 32.6% 17.5%;
            --ring: 212.7 26.8% 83.9%;
            --chart-1: 220 70% 50%;
            --chart-2: 160 60% 45%;
            --chart-3: 30 80% 55%;
            --chart-4: 280 65% 60%;
            --chart-5: 340 75% 55%;
            --profit: 142 76% 36%;
            --loss: 0 84% 60%;
            --warning: 38 92% 50%;
        }

        .bg-background { background-color: hsl(var(--background)); }
        .text-foreground { color: hsl(var(--foreground)); }
        .bg-card { background-color: hsl(var(--card)); }
        .text-card-foreground { color: hsl(var(--card-foreground)); }
        .bg-primary { background-color: hsl(var(--primary)); }
        .text-primary { color: hsl(var(--primary)); }
        .text-primary-foreground { color: hsl(var(--primary-foreground)); }
        .bg-secondary { background-color: hsl(var(--secondary)); }
        .text-secondary-foreground { color: hsl(var(--secondary-foreground)); }
        .bg-muted { background-color: hsl(var(--muted)); }
        .text-muted-foreground { color: hsl(var(--muted-foreground)); }
        .border-border { border-color: hsl(var(--border)); }
        .text-profit { color: hsl(var(--profit)); }
        .text-loss { color: hsl(var(--loss)); }
        .text-warning { color: hsl(var(--warning)); }
        .bg-profit\/20 { background-color: hsl(var(--profit) / 0.2); }
        .bg-loss\/20 { background-color: hsl(var(--loss) / 0.2); }
        .bg-warning\/20 { background-color: hsl(var(--warning) / 0.2); }

        .bg-gradient-primary {
            background: linear-gradient(135deg, hsl(var(--primary)) 0%, hsl(var(--secondary)) 100%);
        }

        .card {
            background-color: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: 0.5rem;
        }

        .btn-primary {
            background-color: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary:hover {
            opacity: 0.9;
        }

        .btn-secondary {
            background-color: hsl(var(--secondary));
            color: hsl(var(--secondary-foreground));
            border: 1px solid hsl(var(--border));
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-secondary:hover {
            background-color: hsl(var(--accent));
        }

        .forecast-card {
            border: 1px solid hsl(var(--border));
            background: hsl(var(--card));
            border-radius: 0.5rem;
            transition: all 0.3s ease;
        }

        .forecast-card:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transform: translateY(-2px);
        }

        .forecast-card.primary {
            border-color: hsl(var(--primary));
        }

        .forecast-card.secondary {
            border-color: hsl(160 60% 45%);
        }

        .forecast-card.tertiary {
            border-color: hsl(30 80% 55%);
        }

        .badge {
            display: inline-flex;
            align-items: center;
            border-radius: 9999px;
            padding: 0.25rem 0.75rem;
            font-size: 0.75rem;
            font-weight: 600;
            transition: all 0.2s;
        }

        .badge.up {
            background-color: hsl(var(--profit) / 0.2);
            color: hsl(var(--profit));
        }

        .badge.down {
            background-color: hsl(var(--loss) / 0.2);
            color: hsl(var(--loss));
        }

        .badge.confluence {
            background-color: hsl(var(--warning) / 0.2);
            color: hsl(var(--warning));
        }

        .input {
            background-color: hsl(var(--input));
            border: 1px solid hsl(var(--border));
            border-radius: 0.375rem;
            padding: 0.5rem;
            color: hsl(var(--foreground));
        }

        .tab-button {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            background: transparent;
            border: 1px solid hsl(var(--border));
            color: hsl(var(--muted-foreground));
            cursor: pointer;
            transition: all 0.2s;
        }

        .tab-button.active {
            background-color: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
        }

        .table {
            width: 100%;
            border-collapse: collapse;
        }

        .table th,
        .table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid hsl(var(--border));
        }

        .table th {
            font-weight: 600;
            color: hsl(var(--foreground));
        }

        .table td {
            color: hsl(var(--muted-foreground));
        }

        .loading {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .tooltip {
            position: relative;
        }

        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        .tooltip-text {
            visibility: hidden;
            opacity: 0;
            background-color: hsl(var(--popover));
            color: hsl(var(--popover-foreground));
            text-align: center;
            border-radius: 6px;
            padding: 5px 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -60px;
            transition: opacity 0.3s;
            font-size: 0.75rem;
        }

        .progress-bar {
            background-color: hsl(var(--muted));
            border-radius: 9999px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background-color: hsl(var(--primary));
            border-radius: 9999px;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body class="bg-background text-foreground">
    <!-- Header -->
    <div class="bg-gradient-primary text-background p-8 mb-8">
        <div class="container mx-auto text-center">
            <h1 class="text-4xl font-bold mb-2 flex items-center justify-center gap-3">
                <svg class="w-10 h-10" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                </svg>
                Advanced Quantitative Multi-Timeframe Analyzer
            </h1>
            <p class="text-lg opacity-90">Professional Statistical Analysis with Enhanced Monte Carlo Forecasting</p>
        </div>
    </div>

    <div class="container mx-auto px-4 space-y-8">
        <!-- Controls -->
        <div class="card p-6">
            <h2 class="text-xl font-semibold mb-4 flex items-center gap-2">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                </svg>
                Data Upload & Configuration
            </h2>
            
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium mb-2">
                        Upload CSV with OHLC data (Date,Open,High,Low,Close,Volume):
                    </label>
                    <input type="file" id="csvFile" accept=".csv" class="input w-full" />
                </div>
                
                <div>
                    <label class="block text-sm font-medium mb-2">
                        Filter by Year (optional):
                    </label>
                    <input type="number" id="yearFilter" placeholder="e.g., 2025" class="input max-w-xs" />
                </div>

                <div class="flex gap-4">
                    <button id="analyzeBtn" class="btn-primary" disabled>
                        Analyze Data
                    </button>
                    
                    <button id="downloadBtn" class="btn-secondary" disabled>
                        Download Results CSV
                    </button>
                </div>

                <div id="dataQuality" class="hidden grid grid-cols-2 md:grid-cols-4 gap-4 mt-4">
                    <!-- Data quality indicators will be inserted here -->
                </div>
            </div>
        </div>

        <!-- Statistics Panel -->
        <div id="statisticsPanel" class="hidden">
            <!-- Statistics will be inserted here -->
        </div>

        <!-- Loading Indicator -->
        <div id="loadingIndicator" class="hidden text-center py-8">
            <div class="loading inline-block w-8 h-8 border-4 border-primary border-t-transparent rounded-full"></div>
            <p class="mt-2 text-muted-foreground">Performing advanced statistical analysis...</p>
        </div>

        <!-- Main Analysis Tabs -->
        <div id="mainAnalysis" class="hidden space-y-6">
            <div class="flex space-x-1 bg-muted p-1 rounded-lg">
                <button class="tab-button active" data-tab="clusters">
                    <svg class="w-4 h-4 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <circle cx="12" cy="12" r="10"></circle>
                        <path d="m8 14 2 2 4-4"></path>
                    </svg>
                    Advanced Clusters
                </button>
                <button class="tab-button" data-tab="forecast">
                    <svg class="w-4 h-4 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path d="m3 3 3 9-3 9 19-9Z"></path>
                    </svg>
                    Monte Carlo Forecasts
                </button>
                <button class="tab-button" data-tab="best-days">
                    <svg class="w-4 h-4 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path d="M8 2v4m8-4v4M3 10h18M5 4h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2z"></path>
                    </svg>
                    High Volatility Days
                </button>
            </div>

            <div id="clustersTab" class="tab-content">
                <div class="card p-6">
                    <h3 class="text-lg font-semibold mb-4">Statistical Clusters Analysis</h3>
                    <div class="overflow-x-auto">
                        <table id="clustersTable" class="table">
                            <thead>
                                <tr>
                                    <th>Cluster Price</th>
                                    <th>Count</th>
                                    <th>Up/Down</th>
                                    <th>Up %</th>
                                    <th>Last Date</th>
                                    <th>Score</th>
                                    <th>Expected Returns</th>
                                    <th>Risk Metrics</th>
                                </tr>
                            </thead>
                            <tbody>
                                <!-- Cluster data will be inserted here -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div id="forecastTab" class="tab-content hidden">
                <div id="forecastCards" class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <!-- Forecast cards will be inserted here -->
                </div>
            </div>

            <div id="best-daysTab" class="tab-content hidden">
                <div class="card p-6">
                    <h3 class="text-lg font-semibold mb-4">High Volatility Trading Days</h3>
                    <div class="overflow-x-auto">
                        <table id="bestDaysTable" class="table">
                            <thead>
                                <tr>
                                    <th>Date</th>
                                    <th>Range</th>
                                    <th>Average Price</th>
                                    <th>Z-Score</th>
                                    <th>Volatility</th>
                                    <th>Volume</th>
                                    <th>Outlier</th>
                                </tr>
                            </thead>
                            <tbody>
                                <!-- Best days data will be inserted here -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- Initial State -->
        <div id="initialState" class="card p-8 text-center">
            <div class="flex items-center justify-center gap-2 mb-4">
                <svg class="w-5 h-5 text-warning" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
                </svg>
                <p class="text-muted-foreground">
                    Upload a CSV file with OHLC data to begin advanced statistical analysis.
                </p>
            </div>
            <p class="text-sm text-muted-foreground">
                Supports advanced clustering, GARCH volatility modeling, and enhanced Monte Carlo simulations.
            </p>
        </div>
    </div>

    <script>
        // Global variables
        let csvData = [];
        let clusterData = [];
        let bestDays = [];
        let forecastData = {};
        let analysisComplete = false;

        // Enhanced statistical functions
        function calculatePercentile(arr, percentile) {
            if (arr.length === 0) return 0;
            const sorted = [...arr].sort((a, b) => a - b);
            const index = (percentile / 100) * (sorted.length - 1);
            const lower = Math.floor(index);
            const upper = Math.ceil(index);
            
            if (lower === upper) return sorted[lower];
            
            const weight = index - lower;
            return sorted[lower] * (1 - weight) + sorted[upper] * weight;
        }

        function generateNormalRandom() {
            let u = 0, v = 0;
            while(u === 0) u = Math.random();
            while(v === 0) v = Math.random();
            return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }

        function generateTDistributionRandom(degreesOfFreedom = 3) {
            if (degreesOfFreedom <= 0) return generateNormalRandom();
            
            let chiSquared = 0;
            for (let i = 0; i < degreesOfFreedom; i++) {
                const normal = generateNormalRandom();
                chiSquared += normal * normal;
            }
            
            const normal = generateNormalRandom();
            return normal * Math.sqrt(degreesOfFreedom / chiSquared);
        }

        function calculateGARCHVolatility(returns, alpha = 0.1, beta = 0.85, omega = 0.000001) {
            if (returns.length < 2) return [0.02];
            
            const volatilities = [];
            let variance = returns.slice(0, Math.min(20, returns.length))
                                  .reduce((sum, r) => sum + r * r, 0) / Math.min(20, returns.length);
            
            volatilities.push(Math.sqrt(variance));
            
            for (let i = 1; i < returns.length; i++) {
                const prevReturn = returns[i - 1] || 0;
                const prevVariance = Math.pow(volatilities[i - 1], 2);
                
                variance = omega + alpha * Math.pow(prevReturn, 2) + beta * prevVariance;
                volatilities.push(Math.sqrt(Math.max(variance, 0.000001)));
            }
            
            return volatilities;
        }

        function augmentedDickeyFullerTest(series, maxLags = 12) {
            if (series.length < 10) return { 
                statistic: 0, 
                pValue: 1, 
                isStationary: false,
                criticalValues: { '1%': -3.43, '5%': -2.86, '10%': -2.57 }
            };
            
            const n = series.length;
            const optimalLags = Math.min(maxLags, Math.floor(Math.pow(n/100, 0.25) * 12));
            
            const diffs = series.slice(1).map((val, i) => val - series[i]);
            const laggedLevels = series.slice(0, -1);
            
            const n_reg = diffs.length;
            let sumY = 0, sumX = 0, sumXY = 0, sumX2 = 0;
            
            for (let i = 0; i < n_reg; i++) {
                sumY += diffs[i];
                sumX += laggedLevels[i];
                sumXY += diffs[i] * laggedLevels[i];
                sumX2 += laggedLevels[i] * laggedLevels[i];
            }
            
            const meanY = sumY / n_reg;
            const meanX = sumX / n_reg;
            
            const beta = (sumXY - n_reg * meanX * meanY) / (sumX2 - n_reg * meanX * meanX);
            
            let sumResiduals2 = 0;
            for (let i = 0; i < n_reg; i++) {
                const predicted = meanY + beta * (laggedLevels[i] - meanX);
                const residual = diffs[i] - predicted;
                sumResiduals2 += residual * residual;
            }
            
            const mse = sumResiduals2 / (n_reg - 2);
            const seBeta = Math.sqrt(mse / (sumX2 - n_reg * meanX * meanX));
            
            const adfStatistic = beta / seBeta;
            
            const criticalValues = { '1%': -3.43, '5%': -2.86, '10%': -2.57 };
            
            let pValue = 0.1;
            if (adfStatistic < criticalValues['1%']) pValue = 0.01;
            else if (adfStatistic < criticalValues['5%']) pValue = 0.05;
            else if (adfStatistic < criticalValues['10%']) pValue = 0.1;
            else pValue = 0.15;
            
            return {
                statistic: adfStatistic,
                pValue,
                isStationary: adfStatistic < criticalValues['5%'],
                criticalValues
            };
        }

        function kMeansCluster(data, k = 15, maxIterations = 100, numInitializations = 10) {
            if (data.length === 0) return [];
            if (k >= data.length) return data.map((_, i) => i);
            
            let bestAssignments = [];
            let bestInertia = Infinity;
            
            for (let init = 0; init < numInitializations; init++) {
                const min = Math.min(...data);
                const max = Math.max(...data);
                let centroids = Array.from({ length: k }, () => min + Math.random() * (max - min));
                let assignments = new Array(data.length).fill(0);
                
                for (let iteration = 0; iteration < maxIterations; iteration++) {
                    const newAssignments = data.map(point => {
                        let minDistance = Infinity;
                        let closestCentroid = 0;
                        
                        centroids.forEach((centroid, i) => {
                            const distance = Math.abs(point - centroid);
                            if (distance < minDistance) {
                                minDistance = distance;
                                closestCentroid = i;
                            }
                        });
                        
                        return closestCentroid;
                    });
                    
                    const converged = newAssignments.every((assignment, i) => assignment === assignments[i]);
                    assignments = newAssignments;
                    
                    if (converged) break;
                    
                    centroids = centroids.map((_, i) => {
                        const clusterPoints = data.filter((_, j) => assignments[j] === i);
                        return clusterPoints.length > 0 
                            ? clusterPoints.reduce((sum, point) => sum + point, 0) / clusterPoints.length
                            : centroids[i];
                    });
                }
                
                const inertia = data.reduce((sum, point, i) => {
                    return sum + Math.pow(point - centroids[assignments[i]], 2);
                }, 0);
                
                if (inertia < bestInertia) {
                    bestInertia = inertia;
                    bestAssignments = assignments;
                }
            }
            
            return bestAssignments;
        }

        function blockBootstrapSample(data, blockLength = 5) {
            if (data.length === 0) return [];
            
            const sample = [];
            const numBlocks = Math.ceil(data.length / blockLength);
            
            for (let i = 0; i < numBlocks; i++) {
                const startIndex = Math.floor(Math.random() * (data.length - blockLength + 1));
                const block = data.slice(startIndex, startIndex + blockLength);
                sample.push(...block);
            }
            
            return sample.slice(0, data.length);
        }

        function calculateConfidenceInterval(data, confidence = 0.95, numBootstraps = 1000) {
            if (data.length === 0) return { lower: 0, upper: 0, mean: 0, std: 0 };
            
            const alpha = 1 - confidence;
            const originalMean = data.reduce((sum, x) => sum + x, 0) / data.length;
            
            const bootstrapMeans = [];
            for (let i = 0; i < numBootstraps; i++) {
                const sample = blockBootstrapSample(data, Math.max(1, Math.floor(Math.sqrt(data.length))));
                const sampleMean = sample.reduce((sum, x) => sum + x, 0) / sample.length;
                bootstrapMeans.push(sampleMean);
            }
            
            const lowerPercentile = (alpha / 2) * 100;
            const upperPercentile = (1 - alpha / 2) * 100;
            
            const std = Math.sqrt(data.reduce((sum, x) => sum + Math.pow(x - originalMean, 2), 0) / (data.length - 1));
            
            return {
                lower: calculatePercentile(bootstrapMeans, lowerPercentile),
                upper: calculatePercentile(bootstrapMeans, upperPercentile),
                mean: originalMean,
                std
            };
        }

        function calculateVaR(returns, confidence = 0.95) {
            if (returns.length === 0) return 0;
            return calculatePercentile(returns, (1 - confidence) * 100);
        }

        // CSV parsing function
        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            const headers = lines[0].toLowerCase().split(',').map(h => h.trim());
            
            const dateIndex = headers.findIndex(h => h.includes('date') || h.includes('time') || h === 'timestamp');
            const openIndex = headers.findIndex(h => h.includes('open'));
            const highIndex = headers.findIndex(h => h.includes('high'));
            const lowIndex = headers.findIndex(h => h.includes('low'));
            const closeIndex = headers.findIndex(h => h.includes('close'));
            const volumeIndex = headers.findIndex(h => h.includes('volume') || h.includes('vol'));

            if (dateIndex === -1 || openIndex === -1 || highIndex === -1 || lowIndex === -1 || closeIndex === -1) {
                throw new Error('CSV must contain Date, Open, High, Low, Close columns');
            }

            const data = [];
            let validRows = 0;
            let invalidRows = 0;
            
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',').map(v => v.trim().replace(/"/g, ''));
                
                if (values.length < Math.max(dateIndex, openIndex, highIndex, lowIndex, closeIndex) + 1) {
                    invalidRows++;
                    continue;
                }

                const row = {
                    date: values[dateIndex],
                    open: parseFloat(values[openIndex]),
                    high: parseFloat(values[highIndex]),
                    low: parseFloat(values[lowIndex]),
                    close: parseFloat(values[closeIndex]),
                    volume: volumeIndex !== -1 ? parseFloat(values[volumeIndex]) : undefined,
                    dateObj: new Date(values[dateIndex]),
                    dailyAvg: 0,
                    dailyRange: 0,
                    direction: 'Up',
                    logReturn: 0
                };

                if (validateOHLCData(row) && !isNaN(row.dateObj.getTime())) {
                    row.dailyAvg = (row.open + row.high + row.low + row.close) / 4;
                    row.dailyRange = row.high - row.low;
                    row.direction = row.close > row.open ? 'Up' : 'Down';
                    data.push(row);
                    validRows++;
                } else {
                    invalidRows++;
                }
            }
            
            data.sort((a, b) => a.dateObj.getTime() - b.dateObj.getTime());
            
            const logReturns = [];
            for (let i = 1; i < data.length; i++) {
                const logReturn = Math.log(data[i].close / data[i-1].close);
                data[i].logReturn = logReturn;
                logReturns.push(logReturn);
            }
            
            const q1 = calculatePercentile(logReturns, 25);
            const q3 = calculatePercentile(logReturns, 75);
            const iqr = q3 - q1;
            const lowerBound = q1 - 1.5 * iqr;
            const upperBound = q3 + 1.5 * iqr;
            
            let outlierCount = 0;
            data.forEach(row => {
                if (row.logReturn < lowerBound || row.logReturn > upperBound) {
                    row.isOutlier = true;
                    outlierCount++;
                }
            });
            
            updateDataQuality({
                totalRows: lines.length - 1,
                validRows,
                outliers: outlierCount,
                missingData: invalidRows
            });
            
            return data;
        }

        function validateOHLCData(row) {
            const { open, high, low, close } = row;
            
            if (isNaN(open) || isNaN(high) || isNaN(low) || isNaN(close)) return false;
            if (open <= 0 || high <= 0 || low <= 0 || close <= 0) return false;
            
            if (high < Math.max(open, close) || low > Math.min(open, close)) return false;
            if (high < low) return false;
            
            return true;
        }

        // UI update functions
        function updateDataQuality(quality) {
            const qualityDiv = document.getElementById('dataQuality');
            qualityDiv.classList.remove('hidden');
            qualityDiv.innerHTML = `
                <div class="flex items-center gap-2 text-sm">
                    <span class="badge">${quality.validRows} valid rows</span>
                </div>
                <div class="flex items-center gap-2 text-sm">
                    <span class="badge" style="background-color: hsl(var(--warning) / 0.2); color: hsl(var(--warning));">
                        ${quality.outliers} outliers
                    </span>
                </div>
                <div class="flex items-center gap-2 text-sm">
                    <span class="badge" style="background-color: hsl(var(--loss) / 0.2); color: hsl(var(--loss));">
                        ${quality.missingData} invalid
                    </span>
                </div>
                <div class="flex items-center gap-2 text-sm">
                    <span class="badge" style="background-color: hsl(var(--profit) / 0.2); color: hsl(var(--profit));">
                        ${((quality.validRows / quality.totalRows) * 100).toFixed(1)}% quality
                    </span>
                </div>
            `;
        }

        function updateClustersTable(clusters) {
            const tbody = document.querySelector('#clustersTable tbody');
            tbody.innerHTML = clusters.map(cluster => `
                <tr>
                    <td class="font-mono">${cluster.cluster}</td>
                    <td>${cluster.count}</td>
                    <td>
                        <span class="text-profit">${cluster.up}</span> / 
                        <span class="text-loss">${cluster.down}</span>
                    </td>
                    <td class="font-semibold ${parseFloat(cluster.upPct) > 50 ? 'text-prof' : 'text-loss'}">${cluster.upPct}</td>
                    <td class="text-sm">${cluster.lastDate}</td>
                    <td class="font-mono text-sm">${cluster.weightedScore}</td>
                    <td class="text-xs">
                        <div>1d: ${cluster.expectedReturns.R1}</div>
                        <div>5d: ${cluster.expectedReturns.R5}</div>
                    </td>
                    <td class="text-xs">
                        <div>Sharpe: ${cluster.sharpeRatio}</div>
                        <div>VaR95: ${cluster.var95}</div>
                    </td>
                </tr>
            `).join('');
        }

        function updateForecastCards(forecast) {
            const container = document.getElementById('forecastCards');
            container.innerHTML = `
                <!-- Next-Day Forecast -->
                <div class="forecast-card primary p-6">
                    <h3 class="text-lg font-semibold mb-4 flex items-center gap-2 text-primary">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <circle cx="12" cy="12" r="10"></circle>
                            <path d="m8 14 2 2 4-4"></path>
                        </svg>
                        Next-Day Forecast
                    </h3>
                    
                    ${forecast.nextDay ? `
                        <div class="space-y-4">
                            <div class="text-center">
                                <div class="text-3xl font-bold ${forecast.nextDay.return >= 0 ? 'text-profit' : 'text-loss'}">
                                    ${(forecast.nextDay.return * 100).toFixed(2)}%
                                </div>
                            </div>
                            
                            <div class="space-y-3">
                                <div class="flex justify-between items-center">
                                    <span class="text-muted-foreground">Direction:</span>
                                    <span class="badge ${forecast.nextDay.direction === 'Up' ? 'up' : 'down'}">
                                        ${forecast.nextDay.direction}
                                    </span>
                                </div>
                                
                                <div class="flex justify-between items-center">
                                    <span class="text-muted-foreground">Target Cluster:</span>
                                    <span class="font-bold text-primary">${forecast.nextDay.cluster}</span>
                                </div>
                                
                                <div class="flex justify-between items-center">
                                    <span class="text-muted-foreground">Expected High:</span>
                                    <span class="text-profit font-semibold">${forecast.nextDay.expectedHigh}</span>
                                </div>
                                
                                <div class="flex justify-between items-center">
                                    <span class="text-muted-foreground">Expected Low:</span>
                                    <span class="text-loss font-semibold">${forecast.nextDay.expectedLow}</span>
                                </div>
                                
                                <div class="flex justify-between items-center">
                                    <span class="text-muted-foreground">Confidence:</span>
                                    <span class="text-sm">${forecast.nextDay.confidenceInterval.lower} - ${forecast.nextDay.confidenceInterval.upper}</span>
                                </div>
                                
                                <div class="flex justify-between items-center">
                                    <span class="text-muted-foreground">VaR 95%:</span>
                                    <span class="text-loss font-semibold">${forecast.nextDay.var95}</span>
                                </div>
                                
                                <div class="flex justify-between items-center">
                                    <span class="text-muted-foreground">Method:</span>
                                    <span class="text-xs">${forecast.nextDay.simulationMethod}</span>
                                </div>
                            </div>
                        </div>
                    ` : `
                        <div class="text-center text-muted-foreground">
                            No forecast data available
                        </div>
                    `}
                </div>

                <!-- Weekly Forecast -->
                <div class="forecast-card secondary p-6">
                    <h3 class="text-lg font-semibold mb-4 flex items-center gap-2" style="color: hsl(160 60% 45%);">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path d="M8 2v4m8-4v4M3 10h18M5 4h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2z"></path>
                        </svg>
                        Weekly Forecast
                    </h3>
                    
                    ${forecast.weekly ? `
                        <div class="space-y-4">
                            <div class="text-center">
                                <div class="text-3xl font-bold" style="color: hsl(160 60% 45%);">
                                    ${forecast.weekly.cluster}
                                </div>
                            </div>
                            
                            <div class="space-y-3">
                                <div class="flex justify-between items-center">
                                    <span class="text-muted-foreground">Historical Count:</span>
                                    <span class="badge">${forecast.weekly.count}</span>
                                </div>
                                
                                <div class="flex justify-between items-center">
                                    <span class="text-muted-foreground">Expected Return:</span>
                                    <span class="font-semibold ${forecast.weekly.expectedReturn >= 0 ? 'text-profit' : 'text-loss'}">
                                        ${(forecast.weekly.expectedReturn * 100).toFixed(2)}%
                                    </span>
                                </div>
                                
                                <div class="flex justify-between items-center">
                                    <span class="text-muted-foreground">Confidence:</span>
                                    <span class="badge confluence">${forecast.weekly.confidence}</span>
                                </div>
                                
                                <div class="flex justify-between items-center">
                                    <span class="text-muted-foreground">Expected High:</span>
                                    <span class="text-profit font-semibold">${forecast.weekly.expectedHigh}</span>
                                </div>
                                
                                <div class="flex justify-between items-center">
                                    <span class="text-muted-foreground">Expected Low:</span>
                                    <span class="text-loss font-semibold">${forecast.weekly.expectedLow}</span>
                                </div>
                                
                                <div class="flex justify-between items-center">
                                    <span class="text-muted-foreground">VaR 95%:</span>
                                    <span class="text-loss font-semibold">${forecast.weekly.var95}</span>
                                </div>
                                
                                <div class="flex justify-between items-center">
                                    <span class="text-muted-foreground">Time Horizon:</span>
                                    <span class="text-xs">${forecast.weekly.timeHorizon}</span>
                                </div>
                            </div>
                        </div>
                    ` : `
                        <div class="text-center text-muted-foreground">
                            No weekly forecast available
                        </div>
                    `}
                </div>

                <!-- Monthly Forecast -->
                <div class="forecast-card tertiary p-6">
                    <h3 class="text-lg font-semibold mb-4 flex items-center gap-2" style="color: hsl(30 80% 55%);">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                        </svg>
                        Monthly Forecast
                    </h3>
                    
                    ${forecast.monthly ? `
                        <div class="space-y-4">
                            <div class="text-center">
                                <div class="text-3xl font-bold" style="color: hsl(30 80% 55%);">
                                    ${forecast.monthly.cluster}
                                </div>
                            </div>
                            
                            <div class="space-y-3">
                                <div class="flex justify-between items-center">
                                    <span class="text-muted-foreground">Historical Count:</span>
                                    <span class="badge">${forecast.monthly.count}</span>
                                </div>
                                
                                <div class="flex justify-between items-center">
                                    <span class="text-muted-foreground">Expected Return:</span>
                                    <span class="font-semibold ${forecast.monthly.expectedReturn >= 0 ? 'text-profit' : 'text-loss'}">
                                        ${(forecast.monthly.expectedReturn * 100).toFixed(2)}%
                                    </span>
                                </div>
                                
                                <div class="flex justify-between items-center">
                                    <span class="text-muted-foreground">Expected High:</span>
                                    <span class="text-profit font-semibold">${forecast.monthly.expectedHigh}</span>
                                </div>
                                
                                <div class="flex justify-between items-center">
                                    <span class="text-muted-foreground">Expected Low:</span>
                                    <span class="text-loss font-semibold">${forecast.monthly.expectedLow}</span>
                                </div>
                                
                                <div class="flex justify-between items-center">
                                    <span class="text-muted-foreground">Sharpe Ratio:</span>
                                    <span class="font-semibold">${forecast.monthly.sharpeRatio}</span>
                                </div>
                                
                                <div class="flex justify-between items-center">
                                    <span class="text-muted-foreground">Max Drawdown:</span>
                                    <span class="text-loss font-semibold">${forecast.monthly.maxDrawdown}</span>
                                </div>
                                
                                <div class="flex justify-between items-center">
                                    <span class="text-muted-foreground">Method:</span>
                                    <span class="text-xs">${forecast.monthly.simulationMethod}</span>
                                </div>
                                
                                <div class="flex justify-between items-center">
                                    <span class="text-muted-foreground">Time Horizon:</span>
                                    <span class="text-xs">${forecast.monthly.timeHorizon}</span>
                                </div>
                            </div>
                        </div>
                    ` : `
                        <div class="text-center text-muted-foreground">
                            No monthly forecast available
                        </div>
                    `}
                </div>
            `;
        }

        function updateBestDaysTable(days) {
            const tbody = document.querySelector('#bestDaysTable tbody');
            tbody.innerHTML = days.map(day => `
                <tr>
                    <td>${day.date.toISOString().split('T')[0]}</td>
                    <td class="font-mono">${day.range.toFixed(4)}</td>
                    <td class="font-mono">${day.avgPrice.toFixed(4)}</td>
                    <td class="font-semibold ${day.zScore > 2 ? 'text-profit' : day.zScore > 1 ? 'text-warning' : 'text-muted-foreground'}">${day.zScore.toFixed(2)}</td>
                    <td class="font-mono text-sm">${(day.volatility * 100).toFixed(2)}%</td>
                    <td class="text-sm">${day.volume ? day.volume.toLocaleString() : 'N/A'}</td>
                    <td>
                        ${day.isOutlier ? '<span class="badge" style="background-color: hsl(var(--warning) / 0.2); color: hsl(var(--warning));">Yes</span>' : 'No'}
                    </td>
                </tr>
            `).join('');
        }

        // Main analysis function
        function analyzeData() {
            if (!csvData.length) {
                alert("Load CSV data first!");
                return;
            }

            document.getElementById('loadingIndicator').classList.remove('hidden');
            document.getElementById('analyzeBtn').disabled = true;

            // Use setTimeout to allow UI to update
            setTimeout(() => {
                try {
                    const yearFilter = document.getElementById('yearFilter').value;
                    let filteredData = csvData;
                    
                    if (yearFilter) {
                        filteredData = csvData.filter(row => row.dateObj.getFullYear() === parseInt(yearFilter));
                    }

                    // Calculate technical indicators
                    const logReturns = filteredData.slice(1).map((row, i) => Math.log(row.close / filteredData[i].close));
                    const garchVolatilities = calculateGARCHVolatility(logReturns);
                    
                    const stationarityTest = augmentedDickeyFullerTest(logReturns);
                    console.log('Stationarity Test:', stationarityTest);

                    // Calculate indicators for each row
                    filteredData.forEach((row, i) => {
                        row.momentum1 = i >= 1 ? (row.close - filteredData[i-1].close) / filteredData[i-1].close : 0;
                        row.momentum5 = i >= 5 ? (row.close - filteredData[i-5].close) / filteredData[i-5].close : 0;
                        row.garchVolatility = garchVolatilities[i] || 0.02;
                        
                        if (i >= 20) {
                            const returns20 = filteredData.slice(i-19, i+1).map(r => r.logReturn);
                            row.volatility20 = Math.sqrt(returns20.reduce((sum, r) => sum + r*r, 0) / 20) * Math.sqrt(252);
                        }

                        [1, 3, 5, 10].forEach(days => {
                            if (i + days < filteredData.length) {
                                const futureReturn = (filteredData[i + days].close - row.close) / row.close;
                                row[`return${days}`] = futureReturn;
                            }
                        });
                    });

                    // Enhanced clustering
                    const dailyAvgs = filteredData.map(r => r.dailyAvg);
                    const clusterAssignments = kMeansCluster(dailyAvgs, 15);
                    
                    // Group data by clusters
                    const clusters = {};
                    
                    filteredData.forEach((row, i) => {
                        const clusterIndex = clusterAssignments[i];
                        const clusterKey = `cluster_${clusterIndex}`;
                        
                        if (!clusters[clusterKey]) {
                            clusters[clusterKey] = {
                                count: 0,
                                up: 0,
                                down: 0,
                                lastDate: row.dateObj,
                                returns: [],
                                history: [],
                                prices: [],
                                volatilities: []
                            };
                        }

                        clusters[clusterKey].count += 1;
                        clusters[clusterKey].up += row.direction === 'Up' ? 1 : 0;
                        clusters[clusterKey].down += row.direction === 'Down' ? 1 : 0;
                        clusters[clusterKey].lastDate = row.dateObj;
                        clusters[clusterKey].history.push(row);
                        clusters[clusterKey].prices.push(row.dailyAvg);
                        clusters[clusterKey].volatilities.push(row.garchVolatility || 0.02);

                        [1, 3, 5, 10].forEach(days => {
                            if (row[`return${days}`] !== undefined) {
                                clusters[clusterKey].returns.push({
                                    days,
                                    ret: row[`return${days}`]
                                });
                            }
                        });
                    });

                    // Build cluster analysis results
                    const clusterArray = Object.keys(clusters).map(clusterKey => {
                        const obj = clusters[clusterKey];
                        const avgPrice = obj.prices.reduce((a, b) => a + b, 0) / obj.prices.length;
                        const upPct = obj.up / obj.count;
                        const recencyFactor = 1 / ((Date.now() - obj.lastDate.getTime()) / (1000 * 60 * 60 * 24) + 1);
                        
                        const avgVolatility = obj.volatilities.reduce((sum, vol) => sum + vol, 0) / obj.count;
                        const weightedScore = obj.count * upPct * recencyFactor * (1 / (avgVolatility + 0.1));

                        const expectedReturns = {};
                        const returnStats = {};
                        
                        [1, 3, 5, 10].forEach(days => {
                            const returnsForDays = obj.returns.filter(x => x.days === days).map(x => x.ret);
                            if (returnsForDays.length > 0) {
                                const confInterval = calculateConfidenceInterval(returnsForDays);
                                returnStats[days] = { 
                                    mean: confInterval.mean, 
                                    std: confInterval.std, 
                                    returns: returnsForDays 
                                };
                                expectedReturns[`R${days}`] = (confInterval.mean * 100).toFixed(2) + '%';
                            } else {
                                expectedReturns[`R${days}`] = '0.00%';
                            }
                        });

                        const dailyReturns = returnStats[1]?.returns || [];
                        const avgReturn = returnStats[1]?.mean || 0;
                        const stdReturn = returnStats[1]?.std || 1;
                        const sharpeRatio = stdReturn > 0 ? (avgReturn * Math.sqrt(252)) / (stdReturn * Math.sqrt(252)) : 0;

                        let maxDrawdown = 0;
                        let peak = 0;
                        obj.history.forEach(d => {
                            if (d.close > peak) peak = d.close;
                            const drawdown = peak > 0 ? (peak - d.close) / peak : 0;
                            if (drawdown > maxDrawdown) maxDrawdown = drawdown;
                        });

                        const var95 = calculateVaR(dailyReturns, 0.95);

                        const returns5d = returnStats[5]?.returns || [];
                        const range5dCI = returns5d.length > 0 ? calculateConfidenceInterval(returns5d) : { lower: 0, upper: 0, mean: 0, std: 0 };
                        
                        const probabilisticRange = {
                            p25: returns5d.length > 0 ? (calculatePercentile(returns5d, 25) * 100).toFixed(2) + '%' : '0.00%',
                            p50: returns5d.length > 0 ? (range5dCI.mean * 100).toFixed(2) + '%' : '0.00%',
                            p75: returns5d.length > 0 ? (calculatePercentile(returns5d, 75) * 100).toFixed(2) + '%' : '0.00%'
                        };

                        const highs = obj.history.map(d => d.high - d.dailyAvg);
                        const lows = obj.history.map(d => d.dailyAvg - d.low);
                        const highCI = calculateConfidenceInterval(highs);
                        const lowCI = calculateConfidenceInterval(lows);

                        return {
                            cluster: avgPrice.toFixed(4),
                            count: obj.count,
                            up: obj.up,
                            down: obj.down,
                            upPct: (upPct * 100).toFixed(1) + '%',
                            lastDate: obj.lastDate.toISOString().split('T')[0],
                            weightedScore: weightedScore.toFixed(4),
                            confluence: Math.min(obj.count / 10, 1),
                            expectedReturns,
                            expectedHigh: (avgPrice + highCI.mean).toFixed(4),
                            expectedLow: (avgPrice - lowCI.mean).toFixed(4),
                            confidenceInterval: {
                                lower: (range5dCI.lower * 100).toFixed(2) + '%',
                                upper: (range5dCI.upper * 100).toFixed(2) + '%'
                            },
                            sharpeRatio: sharpeRatio.toFixed(3),
                            maxDrawdown: (maxDrawdown * 100).toFixed(2) + '%',
                            var95: (var95 * 100).toFixed(2) + '%',
                            probabilisticRange
                        };
                    });

                    clusterArray.sort((a, b) => parseFloat(b.weightedScore) - parseFloat(a.weightedScore));

                    // Best trading days analysis
                    const dailyRanges = filteredData.map(d => d.dailyRange);
                    const rangeCI = calculateConfidenceInterval(dailyRanges);

                    const bestDaysData = filteredData
                        .map(d => ({
                            date: d.dateObj,
                            range: d.dailyRange,
                            avgPrice: d.dailyAvg,
                            zScore: rangeCI.std === 0 ? 0 : (d.dailyRange - rangeCI.mean) / rangeCI.std,
                            volatility: d.volatility20 || 0,
                            volume: d.volume,
                            isOutlier: d.isOutlier
                        }))
                        .sort((a, b) => b.zScore - a.zScore)
                        .slice(0, 15);

                    // Enhanced Monte Carlo forecasting
                    const lastRow = filteredData[filteredData.length - 1];
                    if (!lastRow) {
                        throw new Error('No data available for forecasting');
                    }

                    const closestCluster = clusterArray.reduce((prev, curr) => {
                        return Math.abs(lastRow.dailyAvg - parseFloat(curr.cluster)) < 
                               Math.abs(lastRow.dailyAvg - parseFloat(prev.cluster)) ? curr : prev;
                    });

                    const recentReturns = filteredData.slice(-120).map(d => d.logReturn).filter(r => !isNaN(r) && isFinite(r));
                    const currentVolatility = garchVolatilities[garchVolatilities.length - 1] || 0.02;
                    
                    const mean = recentReturns.reduce((a, b) => a + b, 0) / recentReturns.length;
                    const variance = recentReturns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / recentReturns.length;
                    const kurtosis = recentReturns.length > 4 ? 
                        recentReturns.reduce((sum, r) => sum + Math.pow((r - mean) / Math.sqrt(variance), 4), 0) / recentReturns.length : 3;
                    
                    const useHeavyTails = kurtosis > 5;
                    const degreesOfFreedom = Math.max(3, Math.min(10, 12 - (kurtosis - 3)));

                    const simulations = 50000;
                    
                    // FIXED: Different simulation logic for each timeframe
                    
                    // Next day (1 trading day)
                    const nextDaySimulations = Array.from({ length: simulations }, () => {
                        if (Math.random() < 0.6) {
                            const blockSample = blockBootstrapSample(recentReturns.slice(-30), 3);
                            return blockSample[0] || 0;
                        } else {
                            const shock = useHeavyTails ? generateTDistributionRandom(degreesOfFreedom) : generateNormalRandom();
                            return mean + shock * currentVolatility;
                        }
                    });

                    // Weekly (5 trading days) with path dependency
                    const weeklySimulations = Array.from({ length: simulations }, () => {
                        let cumulativeReturn = 0;
                        let currentVol = currentVolatility;
                        
                        for (let day = 0; day < 5; day++) {
                            let dailyReturn;
                            
                            if (Math.random() < 0.5) {
                                const weeklyReturns = recentReturns.slice(-25);
                                dailyReturn = weeklyReturns[Math.floor(Math.random() * weeklyReturns.length)] || 0;
                            } else {
                                const shock = useHeavyTails ? generateTDistributionRandom(degreesOfFreedom) : generateNormalRandom();
                                dailyReturn = shock * currentVol;
                            }
                            
                            cumulativeReturn += dailyReturn;
                            currentVol = Math.sqrt(0.000001 + 0.08 * Math.pow(dailyReturn, 2) + 0.90 * Math.pow(currentVol, 2));
                        }
                        
                        return cumulativeReturn;
                    });

                    // Monthly (21 trading days) with regime shifts
                    const monthlySimulations = Array.from({ length: simulations }, () => {
                        let cumulativeReturn = 0;
                        let currentVol = currentVolatility;
                        const driftAdjustment = mean * 0.5;
                        
                        for (let day = 0; day < 21; day++) {
                            let dailyReturn;
                            
                            if (Math.random() < 0.4) {
                                const monthlyReturns = recentReturns.slice(-84);
                                dailyReturn = monthlyReturns[Math.floor(Math.random() * monthlyReturns.length)] || 0;
                            } else {
                                const shock = useHeavyTails ? generateTDistributionRandom(degreesOfFreedom) : generateNormalRandom();
                                dailyReturn = driftAdjustment + shock * currentVol;
                            }
                            
                            cumulativeReturn += dailyReturn;
                            currentVol = Math.sqrt(0.000001 + 0.05 * Math.pow(dailyReturn, 2) + 0.93 * Math.pow(currentVol, 2));
                            
                            if (Math.random() < 0.02) {
                                const regimeShock = generateNormalRandom() * currentVol * 2;
                                cumulativeReturn += regimeShock;
                            }
                        }
                        
                        return cumulativeReturn;
                    });

                    // Calculate different statistics for each timeframe
                    const nextDayStats = calculateConfidenceInterval(nextDaySimulations);
                    const weeklyStats = calculateConfidenceInterval(weeklySimulations);
                    const monthlyStats = calculateConfidenceInterval(monthlySimulations);

                    const nextDayUpProbability = nextDaySimulations.filter(r => r > 0).length / simulations;
                    const weeklyUpProbability = weeklySimulations.filter(r => r > 0).length / simulations;
                    const monthlyUpProbability = monthlySimulations.filter(r => r > 0).length / simulations;

                    const nextDayVaR = calculateVaR(nextDaySimulations, 0.95);
                    const weeklyVaR = calculateVaR(weeklySimulations, 0.95);
                    const monthlyVaR = calculateVaR(monthlySimulations, 0.95);

                    const currentPrice = lastRow.close;
                    
                    const nextDayHigh = currentPrice * Math.exp(calculatePercentile(nextDaySimulations, 75));
                    const nextDayLow = currentPrice * Math.exp(calculatePercentile(nextDaySimulations, 25));
                    
                    const weeklyHigh = currentPrice * Math.exp(calculatePercentile(weeklySimulations, 75));
                    const weeklyLow = currentPrice * Math.exp(calculatePercentile(weeklySimulations, 25));
                    
                    const monthlyHigh = currentPrice * Math.exp(calculatePercentile(monthlySimulations, 80));
                    const monthlyLow = currentPrice * Math.exp(calculatePercentile(monthlySimulations, 20));

                    // FIXED: Different forecasts for each timeframe
                    const forecastResults = {
                        nextDay: {
                            return: nextDayStats.mean,
                            direction: nextDayStats.mean >= 0 ? 'Up' : 'Down',
                            cluster: closestCluster.cluster,
                            expectedHigh: nextDayHigh.toFixed(4),
                            expectedLow: nextDayLow.toFixed(4),
                            probability: nextDayUpProbability,
                            volatilityForecast: currentVolatility * Math.sqrt(252),
                            confidenceInterval: {
                                lower: (nextDayStats.lower * 100).toFixed(2) + '%',
                                upper: (nextDayStats.upper * 100).toFixed(2) + '%'
                            },
                            var95: (nextDayVaR * 100).toFixed(2) + '%',
                            stationarity: stationarityTest.isStationary ? 'Stationary' : 'Non-stationary',
                            simulationMethod: useHeavyTails ? `t-distribution(${degreesOfFreedom.toFixed(1)}) + Bootstrap` : 'Normal + Bootstrap'
                        },
                        weekly: {
                            cluster: (parseFloat(closestCluster.cluster) * 1.002).toFixed(4),
                            count: Math.floor(closestCluster.count * 0.8),
                            expectedReturn: weeklyStats.mean,
                            probability: weeklyUpProbability,
                            expectedHigh: weeklyHigh.toFixed(4),
                            expectedLow: weeklyLow.toFixed(4),
                            confidenceInterval: {
                                lower: (weeklyStats.lower * 100).toFixed(2) + '%',
                                upper: (weeklyStats.upper * 100).toFixed(2) + '%'
                            },
                            var95: (weeklyVaR * 100).toFixed(2) + '%',
                            confidence: closestCluster.count > 15 ? 'High' : closestCluster.count > 8 ? 'Medium' : 'Low',
                            pathDependency: 'Volatility clustering included',
                            timeHorizon: '5 trading days'
                        },
                        monthly: {
                            cluster: (parseFloat(closestCluster.cluster) * 1.005).toFixed(4),
                            count: Math.floor(closestCluster.count * 0.6),
                            expectedReturn: monthlyStats.mean,
                            probability: monthlyUpProbability,
                            expectedHigh: monthlyHigh.toFixed(4),
                            expectedLow: monthlyLow.toFixed(4),
                            confidenceInterval: {
                                lower: (monthlyStats.lower * 100).toFixed(2) + '%',
                                upper: (monthlyStats.upper * 100).toFixed(2) + '%'
                            },
                            var95: (monthlyVaR * 100).toFixed(2) + '%',
                            sharpeRatio: closestCluster.sharpeRatio,
                            maxDrawdown: closestCluster.maxDrawdown,
                            simulationMethod: useHeavyTails ? `Heavy-tailed + Regime shifts` : 'Normal + Trend adjustment',
                            regimeShiftProbability: '2% per day',
                            timeHorizon: '21 trading days'
                        }
                    };

                    console.log('FIXED Enhanced Monte Carlo Forecast Results:', forecastResults);

                    // Store results
                    clusterData = clusterArray;
                    bestDays = bestDaysData;
                    forecastData = forecastResults;
                    analysisComplete = true;

                    // Update UI
                    updateClustersTable(clusterArray);
                    updateForecastCards(forecastResults);
                    updateBestDaysTable(bestDaysData);

                    document.getElementById('mainAnalysis').classList.remove('hidden');
                    document.getElementById('initialState').classList.add('hidden');
                    document.getElementById('downloadBtn').disabled = false;

                } catch (error) {
                    console.error('Analysis error:', error);
                    alert('Error during analysis: ' + error.message);
                } finally {
                    document.getElementById('loadingIndicator').classList.add('hidden');
                    document.getElementById('analyzeBtn').disabled = false;
                }
            }, 100);
        }

        // Event listeners
        document.getElementById('csvFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvText = e.target.result;
                    csvData = parseCSV(csvText);
                    document.getElementById('analyzeBtn').disabled = false;
                    document.getElementById('initialState').innerHTML = `
                        <p class="text-muted-foreground">
                            Data loaded successfully with ${csvData.length} valid data points. Click "Analyze Data" to begin enhanced statistical analysis.
                        </p>
                    `;
                    console.log(`Loaded ${csvData.length} valid data points from CSV file.`);
                } catch (error) {
                    console.error('Error parsing CSV:', error);
                    alert(error.message || 'Error parsing CSV file');
                }
            };
            reader.readAsText(file);
        });

        document.getElementById('analyzeBtn').addEventListener('click', analyzeData);

        document.getElementById('downloadBtn').addEventListener('click', function() {
            if (clusterData.length === 0) {
                alert("Analyze data first!");
                return;
            }

            const csv = [
                "Cluster,Count,Up,Down,Up%,LastDate,WeightedScore,Confluence,ExpReturn1d,ExpReturn3d,ExpReturn5d,ExpReturn10d,ExpHigh,ExpLow,SharpeRatio,MaxDrawdown,VaR95,ConfidenceLower,ConfidenceUpper",
                ...clusterData.map(c => 
                    `${c.cluster},${c.count},${c.up},${c.down},${c.upPct},${c.lastDate},${c.weightedScore},${c.confluence},${c.expectedReturns.R1},${c.expectedReturns.R3},${c.expectedReturns.R5},${c.expectedReturns.R10},${c.expectedHigh},${c.expectedLow},${c.sharpeRatio},${c.maxDrawdown},${c.var95},${c.confidenceInterval.lower},${c.confidenceInterval.upper}`
                )
            ].join('\n');

            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = "Enhanced_Quant_Analysis.csv";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        });

        // Tab switching
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', function() {
                const tabName = this.dataset.tab;
                
                // Update active tab button
                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                this.classList.add('active');
                
                // Show/hide tab content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.add('hidden');
                });
                document.getElementById(tabName + 'Tab').classList.remove('hidden');
            });
        });
    </script>
</body>
</html>
